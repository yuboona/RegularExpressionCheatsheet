# 正则匹配技巧

使用python包re

## 基本函数

- `re.match(正则表达式, 原字符串)` 从最开始匹配，但只匹配一次
- `re.findall(正则表达式, 原字符串)` 匹配字符串中所有满足正则表达式的部分
- `re.sub(正则表达式, 替换成什么, 原字符串)` 将正则表达式匹配到的部分替换成任意其他

## 匹配模式的符号

1. `.`匹配除`\n`之外的所有单字符
2. `*`匹配其前方字符的重复多次。
    > 例如`texttext`，`text*`匹配到`textt`
3. `[]`中括号内的内容被分成字符，匹配其中的每个字符，字符间无先后，是‘或’的关系。
    > 例如，`[abc]`匹配`a`或`b`或`c`。
4. `()`中表示一个子表达式，同时可用`(|)`进行有先后的多选匹配，总是匹配其中最先出现的那个字符。
    > 例如，`(abc|a|b)`，匹配三者中最先出现的那个。
5. `\`标记特殊字符（如换行符`\n`），或用来显示**模式符号**的原本含义:`\*`或`\(`。
    > 例如，为了匹配`*`，需要使用`\*`表达式。
6. `?`出现在`*、+`后时，标记前面的子表达式非贪婪（意思是最小匹配，原文中重复多次，但只会匹配其中第一个）。
    > 例如`a.*?b`，只会匹配`accbababaacb`中的第一个`accb`
7. `{n}、{n, n+}`表示匹配的次数的限制。
    > 例如`(text){2}`，匹配`texttext`
8. `^`可以限制正则匹配字符串的开始位置。
    > 例如`^Ab`，则匹配字符串`AbcAb`中的字符串首的Ab，而不能匹配后面出现的`Ab`。
9. `^`在`[^a-z]`中，表示一个取反的正则表达式，匹配a-z以外的所有字符，其中`[]`的用法，参照第3条。
10. `s='adb00000000acb', ab=re.findall( r'a(.*?)b', s, re.S)`，匹配表达式中`()`中的部分。
    > 例如，从`acvbabb`中匹配到`cv`
11. \*\***高难度用法**\*\*：`(1号表达式)(2号表达式)(3号表达式)`，这样用`()`括号，将不同正则表达式括起来后，对字符串进行匹配后，可以用`re.group(1或2或3)`单独获取到三个表达式对应匹配到的字符串。(`re.group(0)`或者不使用`group`则获取整个全局的正则匹配)
12. \*\***高难度用法**\*\*：python版命名组方法`(?P<name>正则表达式)` 使用`re.group('name')`，可以用指定的name匹配某个字符串。

**注意：** 网上一些代码类似，`reg = /a-zA-z/` 其中 `/`符号是某些编程语言中，指示一个正则表达式起止的记号

## 获得中文和英文*标点符号*

```python
    from zhon.hanzo import punctuation
    import string.punctuation
```
